---
title: Linux 系統管理-常見名詞介紹
date: 2023-9-3 02:22
categories: Linux
tags:
    - Linux
---

# 前言
在開始使用系統管理相關的指令前，需要先搞懂常用的名詞，以及各名詞間的關係，才知道要解決問題時要往哪個方向進行，本文會先介紹一些在系統上常用的名詞


# 系統常見名詞

## Application（應用程式） = Service（服務）
* 應用程式（Application）是一個軟體程序，通常用戶可以運行它來執行特定的任務或功能。
* 服務（Service）是在背景運行的一種應用程式，通常無需用戶交互。服務可以在系統啟動時自動運行，並在後台執行特定的任務或提供功能。

## Process（進程）
* 進程是正在運行的某個程序的實例。每個進程都有自己的記憶體空間和資源，並且可以獨立運行。每個進程都有自己的編號(PID)。運行一個命令，會開啟一個進程，如:運行一個`ls`命令，他就會開啟一個進程
* 進程可以同時運行多個任務，並且可以在操作系統的進程管理下進行調度。

## Threads（執行緒）
* 執行緒是在單個進程內運行的單位。一個進程可以包含多個執行緒，這些執行緒共享相同的記憶體空間，但具有自己的執行上下文。
* 執行緒可以實現多任務並行執行，但需要注意處理共享資源的同步和互斥問題。

## Job（作業）
* 指的是終端上運行的一個或多個進程，如:使用了ssh終端連線到linux，並在終端上執行了`sleep 500`命令，`sleep 500`就是該終端上的一個作業，可以使用`jobs`查看當前終端所有的作業有哪些

* 終端 ⇒ 作業(多個or 一個命令，每個命令都有自己的作業號)

* 作業號（Job Number）不同於進程 ID（PID）。作業號是一個 **在終端會話中分配給正在運行的作業的數字標識符，而不是唯一的進程 ID。** 作業號通常從 1 開始遞增。每個作業可以包含一個或多個相關的進程。

* 當在終端上啟動一個命令時，它會形成一個作業，該作業可以包含一個或多個相關的進程。例如，如果您在終端上運行一個後台進程，該作業可能包含一個進程。

* 如果在終端上運行多個命令並將其中一個置於後台運行，每個命令都可以形成一個獨立的作業，每個作業都有其自己的作業號。

## Session（會話）

## 進程組


# 進程相關的名詞

## 後台運行 （Background）

指的是在不占用終端的情況下運行的進程

進程能夠在不阻塞終端下背景執行，用戶可以在終端繼續輸入指令

終端關閉後程序會停止運行

要讓指令在後台運行，可以在指令後面加上 <font color=#EB5757>`&`</font> ， 如 <font color=#EB5757>`sleep 100 &`</font>

或者是一個原本在前台運行的進程，使用 <font color=#EB5757>`ctrl+Z`</font> 將程式暫停執行(掛起)，接著使用 <font color=#EB5757>`bg 作業號`</font>

讓該程式改到後台運行

## 前台運行 （Foreground）

在終端上直接運行的進程，運行中會阻塞終端，用戶無法在終端繼續輸入指令

終端關閉後程序會停止運行

可以使用 <font color=#EB5757>`fg %作業號`</font>  (不是PID)將原本後台執行的指令放到前台

## 掛起 （suspended）

暫時停止一個進程的執行 <font color=#EB5757>`ctrl+Z`</font> ，只能用在前台運行的進程，如果要掛起後台的進程可以先把他叫到前台，或是使用`kill` 指令

常用在可能需要長時間處理的進程，先讓他暫緩執行，或者是操作到一半的工作，想要暫停一下去做其他動作

例如: 正在使用vi 編輯器編輯文件，突然想要做其他事，就可以用 <font color=#EB5757>`ctrl+Z`</font> 將進程暫停，等需要時在使用 <font color=#EB5757>`fg`</font> 指令將原本編輯到一半的vi 編輯器叫回來

## 守護進程（Daemon）
守護進程通常以字母d 結尾，如`Systemd`

大多是系統啟動就運行，直到系統關閉才終止

不依賴於終端，終端關閉後仍會繼續運行

# 切換進程的指令

## ctrl+z 、 ctrl+c

* `ctrl+c`：強制中斷進程，只能中斷前台運行的程序，如果要中斷後台運行的程序要用到`kill`指令

* `ctrl+z`：暫時停止進程 (掛起)

## jobs（要查看當前終端會話中的所有作業及其對應的作業號）

要查看當前終端會話中的所有作業及其對應的作業號，可以使用 `jobs` 命令。這將列出所有正在運行的作業及其狀態。

輸出類似如下
```
    # 分別為 作業號  運行狀態   程序名稱
    [1] Stopped             sleep 500
    [2] Running             tcpdump 
```

## bg（將進程抓到後台去執行）

將進程抓到後台去執行

* 將上一個掛起的進程，拿到後台執行
```bash
    bg
```



* 將指定作業號的進程，拿到後台執行
```bash
    bg 作業號
```

運行完會看到類似輸出
```
    # 分別為 作業號  PID
    [1] 4327

```

## fg（將進程抓到前台終端去執行）

將進程抓到前台終端去執行

* 將上一個掛起的進程，拿到前台執行
```bash
    fg
```

* 將指定作業號的進程，拿到前台執行
```bash
    fg %作業號
```

## nohup（讓一個命令在後台運行，且不受終端關閉影響）

讓一個命令在後台運行，且不受終端關閉影響

雖然 nohup 可以讓一個進程在後台持續運行，但它並不會自動將該進程轉化為典型的守護進程。它仍然與終端會話相關聯，只是在終端關閉後也繼續運行。

運行時預設會創建一個`nohup.out`文件紀錄指令運行的過程

```bash
    nohup 指令 &
```

* 輸出到指定文件
```bash
    nohup sleep 500 > custom.out &
```
* 將標準錯誤輸出到指定文件
```bash
    nohup sleep 500 > custom.out 2>&1 &
```
<font color=#EB5757>`2>&1`</font> ，2 為標準錯誤，1為標準輸出，也就是將標準錯誤的輸出，覆蓋掉原本標準輸出的位置`custom.out`

* 忽略標準輸出 跟 標準錯誤 的訊息
```bash
    nohup sleep 500 > /dev/null  2>&1 &
```
<font color=#EB5757>`/dev/null`</font> ，是一個特殊設備文件，他將一切寫入他的輸入給丟棄

    <font color=#EB5757>`2>&1`</font>， 把標準錯誤輸出也一起丟到標準輸入中，也就是把標準錯誤也一起丟到 <font color=#EB5757>`/dev/null`</font>



## 範例介紹-使用sleep 指令練習 進程切換

1. 先在前台運行sleep 指令

    `sleep 500`，這個指令會占用終端指定秒數(500)後，再將終端返回給用戶，適合拿來練習操作掛起、後台執行等操作

2. 將它掛起 <font color=#EB5757>`ctrl+Z`</font>

    此時 `sleep 500` 這個進程暫時停止了

3. 使用 `jobs` 指令查看當前的任務有哪些，可以看到

    ```bash
        # 以下資訊分別為
        # 作業號 ,  進程狀態  , 運行的程式名稱

        [1]+ Stopped     sleep 500
    ```

    或是想要使用 `ps -ef | grep sleep` 檢查進程是否還在

4. 若想讓 `sleep 500` 在後台執行，輸入 <font color=#EB5757>`bg 作業號`</font>，也就是 <font color=#EB5757>`bg 1`</font> ，或是使用<font color=#EB5757>`bg`</font> 重新讓上一次掛起的進程再度開始在後台執行，運行完會出現類似 作業號,  PID 的輸出

    ```bash
    # 作業號  PID
    [1]  4237
    ```

5. 如果一開始執行就想要讓他在後台執行可以使用 <font color=#EB5757>`指令 &`</font> ，也就是 `sleep 500 &` 


6. 若想將 `sleep 500` 回到前台執行 使用 <font color=#EB5757>`fg %作業號`</font> ，也就是 <font color=#EB5757>`fg %1`</font>


7. 最後不想執行了，使用 <font color=#EB5757>`ctrl+c`</font> 停止

# 參考
[bg和fg指令（整理）以及 Linux中Ctrl+C、Ctrl+D等按键操作&进程相关命令](https://blog.csdn.net/deniece1/article/details/102770363)

[搞懂进程组、会话、控制终端关系，才能明白守护进程如何创建](https://zhuanlan.zhihu.com/p/266720121)

[什么是守护进程？](https://www.zhihu.com/question/38609004)